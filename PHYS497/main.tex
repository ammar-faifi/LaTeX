% vim: foldmethod=marker foldmarker=(fold),(end)
\documentclass{article}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{geometry}[margin=20mm]
\usepackage{listings}

\def\c#1{\texttt{#1}}

\title{Physics Undergraduate Research (PHYS497)}
\author{Alfaifi, Ammar -- 201855360}
\date{Nov. 2023}

\begin{document}
\maketitle

\section{Instroduction} % (fold)
\label{sec:Instroduction}
This paper shows the idea of relizaion of braiding of Majorana fermions but as
series of measurement istead. And then using Jordan-Wigner transformation to
write Majorana operators in terms of spin (fermionic) system. Hence, we can use
methods provided by \c{qiskit} package to simulate such an idea and system.
% section Instroduction (end)

\section{As Series of Measurement} % (fold)
\label{sec:As Series of measurement}
As a demostration for the idea, we'll start with a system of 4 Majorana fermions,
corresponding to two fermions. The configuration of Majorana fermions is shown in fig.
The true braiding operator between $\gamma_0$ and $ \gamma_3 $ is given by
\begin{equation}
	U = e^{\frac{\pi}{4} \gamma_0 \gamma_3}
	\label{eq:braiding op}
\end{equation}
Then, to relize this braiding operator as just series of measurement we do this in four steps:
\begin{enumerate}
	\item $ (1 + i \gamma_1 \gamma_2) $
	\item $ (1 + i \gamma_1 \gamma_0) $
	\item $ (1 + i \gamma_3 \gamma_1) $
	\item $ (1 + i \gamma_1 \gamma_2) $
\end{enumerate}
% section As Series of measurement (end)

\section{Jordan-Wigner Transformation} % (fold)
\label{sec:Jordan-Wigner Transformation}
We shall redefine the our $ \gamma $ s in term of fermionic spin operators, giving us a way to model
this system in much more fimiliar systems, such as qubits in quantum computing information. So we'll have:
\begin{itemize}
	\item $ \gamma_0 = Z_0 $
	\item $ \gamma_1 = X_0 Z_1 $
	\item $ \gamma_2 = X_0 Y_1 $
	\item $ \gamma_3 = Y_0 $
\end{itemize}
Note: tensor product is understod, if there is one gate, tensor product with indentity of that subsystem is implicit.
Then 4-step series of measurement on the system becomes
\begin{enumerate}
	\item $ (1 + i X_0 Z_1 X_0 Y_1) = (1 + X_1) $
	\item $ (1 + i X_0 Z_1 Z_0) = (1 + Y_0 Z_1) $
	\item $ (1 + i Y_0 X_0 Z_1) = (1 + Z_0 Z_1) $
	\item $ (1 + X_1) $
\end{enumerate}
Also for true braiding operator we get
\begin{equation}
	e^{i \frac{\pi}{4} X_0} = \frac{1}{\sqrt{2}}\, (1 + i X_0 ) \quad \text{or} \quad
	e^{-i \frac{\pi}{4} X_0} = \frac{1}{\sqrt{2}}\, (1 - i X_0 )
	\label{eq:br Jordan-Wigner}
\end{equation}
% section Jordan-Wigner Transformation (end)

\section{Applying all Measurements} % (fold)
\label{sec:Applying all Measurements}
Let's understand the possible outcomes from the general case of the measurement operator,
that is,
\begin{equation}
	(1 +S_3 X_1) (1 +S_2 Z_0 Z_1) (1 +S_1 Y_0 Z_1) (1 +S_0 X_1)
	\label{eq:general meas}
\end{equation}
Expanding the middle two factors as
\begin{equation}
	(1 +S_3 X_1) (1 + S_2 Z_0 Z_1 + S_1 Y_0 Z_1 + S_2 S_1 Z_0 Z_1 Y_0 Z_1) (1 +S_0 X_1)
	\label{eq:expanding}
\end{equation}
Utilizing the Pauli gates anitcommutation relations, we move the LHS factor to RHS,
as for first term we get
\begin{equation*}
	(1 +S_3 X_1) (1 +S_0 X_1) = \delta_{S_0,S_3}\, (1 +S_0 X_1)
\end{equation*}
For second term,
\begin{equation*}
	(1 +S_3 X_1) S_2 Z_0 Z_1 (1 +S_0 X_1) = \delta_{S_0,-S_3}\, S_2 Z_0 Z_1 (1 +S_0 X_1)
\end{equation*}
For the 3rd term,
\begin{equation*}
	(1 +S_3 X_1) S_1 Y_0 Z_1 (1 +S_0 X_1) = \delta_{S_0,-S_3}\, S_1 Y_0 Z_1 (1 +S_0 X_1)
\end{equation*}
For the 3rd term,
\begin{equation*}
	(1 +S_3 X_1) S_2 S_1 Z_0 Z_1 Y_0 Z_1 (1 +S_0 X_1) = \delta_{S_0,S_3}\, -i X_0 S_2 S_1 (1 +S_0 X_1)
\end{equation*}
% section Applying all Measurements (end)

\section{Constructing Protocol} % (fold)
\label{sec:Constructing Protocol}
Now, we'll investigate the protocol classic outcomes, then we shall decide based on it whether
we did relize a braiding between $ \gamma_0 $ \& $ \gamma_3 $, if not, what operators
to apply to fix it. From Section~\ref{sec:Applying all Measurements}, we simplify it to
\begin{equation*}
	[
		\delta_{S_0,S_3} + \delta_{S_0,-S_3}\, S_2 Z_0 Z_1
		+ \delta_{S_0,-S_3}\, S_1 Y_0 Z_1 + \delta_{S_0,S_3}\, -i X_0 S_2 S_1
	] (1 +S_0 X_1)
\end{equation*}

Let's study different cases:
\begin{description}
	\item[Case 1: $ S_0 = S_3 $]
		We get \begin{equation*}
			[1 -i X_0 S_2 S_1] (1 + S_0 X_1)
		\end{equation*}
		Note, the right factor just acts on subsystem 1 that we don't care about
		it outcomes.

		\begin{description}
			\item[Case 1.1: $ S_1 = -S_2 $]
				\begin{equation*}
					[1 + i X_0] (1 + S_0 X_1)
				\end{equation*}
				relizing counterclockwise braiding operator in Equation~\ref{eq:br Jordan-Wigner}.
			\item[Case 1.2: $ S_1 = S_2 $]
				\begin{equation*}
					[1 - i X_0] (1 + S_0 X_1)
				\end{equation*}
				relizing clockwise braiding operator in Equation~\ref{eq:br Jordan-Wigner}.
		\end{description}

	\item[Case 2: $ S_0 \ne S_3 $]
		We get \begin{equation*}
			[S_2 Z_0 Z_1 + S_1 Y_0 Z_1]\, (1 + S_0 X_1)
		\end{equation*}
		let's factor out $ Z_0 Z_1 $
		\begin{equation*}
			Z_0 Z_1 [S_2 - i S_1 X_0]\, (1 + S_0 X_1)
		\end{equation*}

		In this case we always want to multiply by $ Z_0 $, then we'll have
		\begin{description}
			\item[Case 2.1: $ S_1 = S_2 $]
				\begin{equation*}
					S_1 Z_0 Z_1 [1 - i X_0] (1 + S_0 X_1)
				\end{equation*}
				relizing the inverse braiding operator
			\item[Case 2.2: $ S_1 = - S_2 $]
				\begin{equation*}
					S_1 Z_0 Z_1 [S_1 S_2 - i X_0] (1 + S_0 X_1)
				\end{equation*}
				But $ S_1 S_2 = -1 $, then
				\begin{equation*}
					- S_1 Z_0 Z_1 [1 + i X_0] (1 + S_0 X_1)
				\end{equation*}
				relizing the braiding operator
		\end{description}
\end{description}
% section Constructing Protocol (end)

\section{Statevector and Density Matrix} % (fold)
\label{sec:Statevector and Density Matrix}
Assume you have a state vector $|\psi\rangle$, which is a column vector with complex numbers:
\begin{equation}
	|\psi\rangle = \begin{bmatrix} \psi_1 \\ \psi_2 \\ \vdots \\ \psi_n \end{bmatrix}
\end{equation}
Here, $n$ is the dimensionality of the quantum system.
Take the conjugate transpose of the state vector, denoted by $\langle \psi|$. This is obtained by taking the complex conjugate of each element and then transposing the vector:
\begin{equation}
	\langle \psi| = \begin{bmatrix} \psi_1^* & \psi_2^* & \ldots & \psi_n^* \end{bmatrix}^T
\end{equation}
Compute the outer product to obtain the density matrix $\rho$:
\begin{equation}
	\rho = |\psi\rangle \langle \psi| = \begin{bmatrix} \psi_1 \\ \psi_2 \\ \vdots \\ \psi_n \end{bmatrix} \begin{bmatrix} \psi_1^* & \psi_2^* & \ldots & \psi_n^* \end{bmatrix}
\end{equation}
The result is a square matrix of size $n \times n$, representing the density matrix.
The density matrix $\rho$ is Hermitian (equal to its conjugate transpose) and positive semi-definite. If the state vector $|\psi\rangle$ is normalized (has a magnitude of 1), then the trace of the density matrix is equal to 1, which is a requirement for a valid density matrix representing a physical state.


\textbf{Pure State:}

For a pure state density matrix $\rho$, which satisfies $\rho^2 = \rho$ (idempotent), you can find the state vector $|\psi\rangle$ by:
\[ |\psi\rangle = \sqrt{\lambda} \cdot |\phi\rangle \]
Here, $\lambda$ is the non-zero eigenvalue of $\rho$, and $|\phi\rangle$ is the corresponding eigenvector.

\textbf{Mixed State:}
For a mixed state density matrix $\rho$ with multiple non-zero eigenvalues, it is not possible to uniquely determine a single state vector. The system is in a statistical mixture of pure states. However, you can find a set of state vectors and their corresponding probabilities:
\[ \rho = \sum_i p_i |\psi_i\rangle\langle\psi_i| \]
Here, $|\psi_i\rangle$ are the eigenvectors of $\rho$, and $p_i$ are the corresponding eigenvalues. The state vectors represent the pure states in the mixture, and the probabilities $p_i$ give the weight of each pure state in the mixture.

\textbf{Implementation:}
To implement this in practice, you can use a numerical linear algebra library (such as NumPy for Python) to compute the eigenvalues and eigenvectors of the density matrix. Depending on the specific form of the density matrix, you might need to use different methods.
Keep in mind that this process may not be unique, especially for mixed states, where different sets of pure states and probabilities can lead to the same density matrix.
% section Statevector and Density Matrix (end)

\newpage
\begin{lstlisting}[language=Python]
def to_statevector(self, atol: float | None = None, rtol: float | None = None) -> Statevector:
    """Return a statevector from a pure density matrix.

    Args:
        atol (float): Absolute tolerance for checking operation validity.
        rtol (float): Relative tolerance for checking operation validity.

    Returns:
        Statevector: The pure density matrix's corresponding statevector.
            Corresponds to the eigenvector of the only non-zero eigenvalue.

    Raises:
        QiskitError: if the state is not pure.
    """

    if atol is None:
        atol = self.atol
    if rtol is None:
        rtol = self.rtol

    if not is_hermitian_matrix(self._data, atol=atol, rtol=rtol):
        raise QiskitError("Not a valid density matrix (non-hermitian).")

    evals, evecs = np.linalg.eig(self._data)

    nonzero_evals = evals[abs(evals) > atol]
    if len(nonzero_evals) != 1 or not np.isclose(nonzero_evals[0], 1, atol=atol, rtol=rtol):
        raise QiskitError("Density matrix is not a pure state")

    psi = evecs[:, np.argmax(evals)]  # eigenvectors returned in columns.
    return Statevector(psi)
\end{lstlisting}

\begin{lstlisting}[language=Python]
@classmethod
def from_instruction(cls, instruction: Instruction | QuantumCircuit) -> DensityMatrix:
    """Return the output density matrix of an instruction.

    The statevector is initialized in the state :math:`|{0,\\ldots,0}\\rangle` of
    the same number of qubits as the input instruction or circuit, evolved
    by the input instruction, and the output statevector returned.

    Args:
        instruction (qiskit.circuit.Instruction or QuantumCircuit): instruction or circuit

    Returns:
        DensityMatrix: the final density matrix.

    Raises:
        QiskitError: if the instruction contains invalid instructions for
                     density matrix simulation.
    """
    # Convert circuit to an instruction
    if isinstance(instruction, QuantumCircuit):
        instruction = instruction.to_instruction()
    # Initialize an the statevector in the all |0> state
    num_qubits = instruction.num_qubits
    init = np.zeros((2**num_qubits, 2**num_qubits), dtype=complex)
    init[0, 0] = 1
    vec = DensityMatrix(init, dims=num_qubits * (2,))
    vec._append_instruction(instruction)
    return vec
\end{lstlisting}
\end{document}
